# Логгирование

Логгирование (журналирование) служит для разных целей. Для отладки программы здесь и сейчас; для информирования пользователя о каких-либо факторах; в конце концов, для того, чтобы пользователь смог, связавшись в Вами по повожу ошибки, предоставить больше информации для её отлова. Если для небольших проектов отсутствие журналирования некритично, то для крупных без него будет впоследствии ну крайне неудобно.

Обычно логгирование делится на несколько уровней, где каждый следующий включает в себя все предыдущие:

1) Критические ошибки (неотключаемый уровень);
2) Предупреждения и необходимая информация (уровень по умолчанию);
3) Дополнительная информация;
4) Уведомления разработчика;
5) Сообщения отладки.

Обычному пользователю практически всегда достаточно и второго уровня.

##  Реализация

Так как желательно, чтобы пользователь мог сам выбирать текущий уровень журналирования, лучше и проще всего для уровня использовать CVar (см. 3.14). Вероятнее всего, её переключение будет в самом низу списка настроек. Мне всегда хватало четырёх из пяти уровней — критический, основной, с дополнительной информацией и отладочный. Уведомления разработчика распределяю в последние два.

Для простоты положим, что наша консольная переменная будет называться "`loglevel`" (о культуре названия переменных также см. 3.14), а также что она серверная. Условимся, что у нас также есть следующие константы:

```C++
enum ELogLevels {
	LL_Emergency = 0,
	LL_Main,
	LL_Detailed,
	LL_Debug
};
```

#### Первый вариант реализации

Самый простой способ — каждый раз перед участком кода получать CVar и отправлять сообщение, если его значение меньше либо равно указанному.

```C++
int loglevel = CVar.FindCVar( "loglevel" ).GetInt();

if ( loglevel >= LL_Detailed )
	console.printf( "Something started." );

if ( loglevel >= LL_Debug )
	console.printf( "[Debug] Consoleplayer: " .. consoleplayer );

if ( loglevel >= LL_Main )
	console.printf( "Ready." );
```

Очевидно, что постоянно прописывать сравнения не совсем удобно, да и программа может бесплатно разрастись. С учётом этого вытекает другой вариант, гораздо более удобный для крупных программ.


#### Второй вариант реализации

Основан на очевидном утверждении, что гораздо проще использовать API специализированного класса.

```C++
// Скопировать со своих проектов!
// В таком виде он не нужен, так как не учитывается CVar.
class Logger: Thinker {
	const CEMERGENCY = TEXTCOLOR_FIRE;
	const CINFO = "\c-";
	const CDEBUG = TEXTCOLOR_DARKGRAY;

	void Emergency( String msg ) {
		console.printf( CEMERGENCY .. "[Emergency] " .. msg );
	}
	
	void Info( String msg ) {
		console.printf( CINFO .. "[Info] " .. msg );
	}
	
	void Details( String msg ) {
		console.printf( CINFO .. "[Extra info]:" .. msg );
	}
	
	void Debug( String msg ) {
		console.printf( CDEBUG .. "[Debug]" .. msg );
	}
}

// <...>

Logger.Details( "Something started." );

Logger.Debug( "Consoleplayer: " .. consoleplayer );

Logger.Info( "Ready." );
```

