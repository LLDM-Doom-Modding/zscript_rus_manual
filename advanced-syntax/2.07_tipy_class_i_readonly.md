# Шаблоны class<> и readonly<>

В ZScript, в отличие от многих языков, класс является не формой для компилятора, а отдельной структурой данных, у которой существует адрес. Благодаря этому можно брать какие-либо предустановленные характеристики без создания экземпляра, а также "на лету" формировать строку-название и по ней находить нужный класс.

## "class<базовый\_класс>"

Указатель на класс, который входить в цепь наследования от класса `базовый_класс` . Почти всегда указывается название класса:

```cpp
class<Actor> a = "DoomImp";
class<Demon> dem = "Spectre";

console.printf( "Inherited from actor: " .. a.GetClassName() .. ", Inherited from pinky: " .. dem.GetClassName() );
// "Inherited from actor: DoomImp, Inherited from pinky: Spectre"
```

При попытке присвоения класса, не входящего в цепь наследования, переменной присваивается `NULL` (поведение аналогично оператору "`is`", см. 2.02):

```cpp
class<Actor> a = "DoomImp";
console.printf( "As DoomImp: " .. a );
// Вывод: "As DoomImp: <адрес_класса_в_памяти>"

a = "Thinker";
console.printf( "As Thinker: " .. a );
// Вывод: "As Thinker: NULL"

a = "Arachnotron";
console.printf( "As Arachnotron: " .. a );
// Вывод: "As Arachnotron: <адрес_класса_в_памяти>"
```

Объявление класса без указания базового класса и без скобок "больше-меньше" аналогично объявлению его как "`class<Object>`":

```cilkcpp
// Следующие две строки равнозначны:
class menuclass1 = "OptionMenu";
class<Object> menuclass2 = "OptionMenu";

// И эти две — тоже равнозначны:
class th1 = "Thinker";
class<Object> th2 = "Thinker";
```
