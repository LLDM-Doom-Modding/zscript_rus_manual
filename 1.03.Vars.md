# Работа с переменными

Практически все операции над переменными перешли в ZScript с языков C и C++.

В объявлении переменных сначала идёт тип данных для этой переменной, после — её название (идентификатор). Разрешается объявлять несколько переменных через запятую.

"Имя" переменной может состоять из цифр, букв латинского алфавита и нижних подчёркиваний, притом первой должна идти либо буква, либо подчёркивание.

```C
<тип_данных> <идентификатор> [, <идентификатор> [, ...]];

// Например:
int health;
double progress100;
bool alreadyProcessed;
bool _initialized;
```



## Числовые операции

В ZScript представлены базовые операции арифметики и элементарной алгебры: сложение, деление, деление по модулю (получение остатка), взятие абсолютного значение и так далее. Их поддерживают все встроенные целочисленные и вещественные типы данных.

### Арифметика и стандартные операторы

Положим, что `a`, `b` и `x` — любые числовые переменные.

* `a + b`: сложение;
* `a - b`: вычитание;
* `a * b`: умножение;
* `a / b`: деление;
* `a % b`: деление по модулю (взятие остатка);
* `a++`: постинкремент (прибавление единицы к значению переменной);
* `a--`: постдекремент (вычитание единицы от значения переменной);
* `++a`: преинкремент (прибавление единицы к значению переменной до остальных операций);
* `--a`: предекремент (вычитание единицы от значения переменной до остальных операций);

Функции округления возвращают вещественное число, а не целочисленное, как можно было бы предполагать:

* `round( x )`: округление до ближайшего целого;
* `ceil( x )`: округление до ближайшего целого вверх;
* `floor( x )`: округление до ближайшего целого вниз;

* `abs( x )`: модуль числа (абсолютное значение);
* `sqrt( x )`: извлечение квадратного корня;
* `exp( x )`: экспонента ("`e^x`");
* `log( x )`: натуральный логарифм (по основанию `e`);
* `log10( x )`: логарифм по основанию 10;
* `max( a, b [, ...] )`: получение максимального числа из списка значений;
* `min( a, b [, ...] )`: получение минимального числа из списка значений;
* `clamp( x, a, b )`: фиксирование значения переменной `x` между нижней границей `a` и верхней `b` (возвращает значение не меньше `a` и не больше `b`);

### Операторы сравнения

* `a == b`: проверка на равенство двух переменных (не только чисел);
* `a != b`: проверка на неравенство двух переменных;
* `a > b`: проверка на то, что число `a` больше числа `b`;
* `a >= b`: проверка на то, что число `a` больше либо равно числу `b`;
* `a < b`: проверка на то, что число `a` меньше числа `b`;
* `a <= b`: проверка на то, что число `a` меньше либо равно числу `b`.

### Логические операторы

Часто применяются в условных операторах (операторах ветвления).

* `a && b`: логическое "И" ("AND"). Возвращает истину тогда и только тогда, когда оба значения истинны;
* `a || b`: логическое "ИЛИ" ("OR"). Возвращает истину тогда, когда хотя бы одно значение истинно;
* `!a`: логическое "НЕ" ("NOT"). Возвращает значение, противоположное исходному. Грубо говоря, превращает "ложь" (0) в "истину" (1), а "истину" (1) в "ложь" (0).

"Таблицы" истинности:
```m
0 && 0 == 0;
0 && 1 == 0;
1 && 0 == 0;
1 && 1 == 1;

0 || 0 == 0;
0 || 1 == 1;
1 || 0 == 0;
1 || 1 == 1;

!0 == 1;
!1 == 0.
```


### Битовые операторы

Доступны только для целочисленных типов. Соответственно, `a` и `b` — целые.

Скорость исполнения этих команд процессором относительно логических операторов не меняется.

* `a & b`: битовое "И" ("AND"). Проводит операцию "И" для каждой соответственной пары битов из `a` и `b`;
* `a | b`: битовое "ИЛИ" ("OR"). Проводит операцию "ИЛИ" для каждой соответственной пары битов из `a` и `b`;
* `a ^ b`: битовое "ИСКЛЮЧАЮЩЕЕ ИЛИ" ("XOR"). Осуществляет проверку на неравенство для каждой соответственной пары битов из `a` и `b`;
* `~a`: битовое "НЕ" ("NOT"). Изменяет все биты на противоположные;
* `a << b`: битовое смещение влево. Смещает биты `a` на `b` битов влево с потерей старших;
* `a >> b`: битовое смещение вправо. Смещает биты `a` на `b` битов вправо с потерей младших.

Примеры результатов перечисленных операций на неких случайно выбраннвх мной числах (символ "`₂`" снизу после числа означает систему счисления по основанию "2" — сообственно, представление в битах):

```m
    AND:            OR:           XOR:
  11011010₂      01010010₂      01010010₂
& 01111100₂    | 10001010₂    ^ 11010011₂
  --------       --------       --------
  01011000₂      11011010₂      10000001₂


NOT: ~11000110₂  ==  00111001₂

SHL: 00111001₂ << 2  ==  11100100₂
     11111000₂ << 3  ==  11000000₂

SHR: 11010101₂ >> 3  ==  00011010₂
```



## Операторы присваивания

Присвоение любой переменной осуществляется через знак равенства:

* `a = b`: присвоить переменной `a` значение `b`;

Также существуют составные операторы присвоения:

* `a += b`: присвоить переменной `a` значение `a + b`;
* `a -= b`: присвоить переменной `a` значение `a - b`;
* `a *= b`: присвоить переменной `a` значение `a * b`;
* `a /= b`: присвоить переменной `a` значение `a / b`;
* `a %= b`: присвоить переменной `a` значение `a % b`;
* `a <<= b`: присвоить переменной `a` значение `a << b`;
* `a >>= b`: присвоить переменной `a` значение `a >> b`;
* `a &= b`: присвоить переменной `a` значение `a & b`;
* `a |= b`: присвоить переменной `a` значение `a | b`;
* `a ^= b`: присвоить переменной `a` значение `a ^ b`;

### Присвоение значений по умолчанию

В переменных внутри функций (см. 1.09 — "Методы") и в некоторых других случаях можно устанавливать значения по умолчанию. Далее я буду этим активно пользоваться.

```C
<тип_данных> <идентификатор> [= <умолчание>] [, <идентификатор> [= <умолчание>] [, ...]];

// Например:
int health = 100;
String showString = "Nothing to show now";
```

Также перед типом данных можно указывать ключевые слова-модификаторы (см. 2.01) — но в базовом разделе о них речи не пойдёт.

```C
[<модификаторы>] <тип_данных> <идентификатор> [, <идентификатор> [, ...]];
```




## Обращение по указателю

_Все неизвестные слова в этом подразделе можно принять как данность — чуть позже, в следующих статьях, они станут понятны._

Для того, чтобы обратиться к определённому полю/методу какого-либо сложного типа данных (экземпляра класса, структуры и так далее), необходимо после его идентификатора поставить точку и затем — название поля/метода. Эта конструкция уже встречалась и ранее:

```CPP
// Обращение к методу "printf()" встроенной структуры "console":
console.printf( "Logged." );
```



## Конвертация типов

Зачастую ZScript сам определяет, во что нужно превратить тот или иной тип данных в той или иной ситуации. Но иногда ему эту информацию необходимо дать напрямую.

### Преобразование элементарного типа

Для того, чтобы явно указать, какой тип данных необходимо получить, нужно "обернуть" выражение в скобки с указанием типа перед ними:

```C
double b = 45.7;

int a = int( round( b ) ); // Сначала выполнится "round( b )" == "round( 45.7 )" == "46.0", затем — преобразование в целочисленное ("46").

int c = int( ceil( b / 0.63 + b ) ); // "ceil( 45.7 / 0.63 + 45.7 )" == "ceil( 72.5397 + 45.7 )" == "ceil( 118.2397 )" == "119.0". После приведения к целому получится "119".
```

К слову, работает это не только с числами (например, см. 1.10, "Приведение типа класса").

### Заметки о делениях

При взятии остатка от деления по модулю ("`%`") происходит автоконвертация в `int` с округлением до ближайшего целого _(Уточнить на разных версиях)_.

Также стоит обратить внимание на деление целого и вещественного:

```C
double double1 = 7.5;
double double2 = 2.25;
int int1 = 8;
int int1 = 2;

double1 / double2; // Результат — "double".
int1 / double1; // Результат — "double".
double1 / int1; // Результат — "int".
int1 / int2; // Результат — "int".
```

Как видно, на то, какой тип данных получится после деления, влияет знаменатель. Для того, чтобы исправить это, достаточно обернуть его в нужный тип:

```C
double1 / int1; // Результат — "int".

double1 / double( int1 ); // Результат — "double".
int1 / double( int2 ); // Результат — "double".
```
