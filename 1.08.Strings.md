# Строки

Работа со строками в ZScript представлена довольно обширно. Тут и встроенная конкатенация, и разбиение на символы, и перевод строки в int или double, и сравнение без учёта регистра букв.

Тип: "`String`". По умолчанию инициализируется пустой строкой ("`""`").

Строкой в ZScript называется набор символов, заключённый в двойные кавычки. В длине ограничен максимальным фрагментом нераспределённой памяти — на практике можно считать, что лимита нет.

Примеры:

```CPP
String nothingString;
String message = "This is a message.";
```


## Операции над строками

`..`: конкатенация (объединение) строк в одну.

`String.Format()`: статический метод. См. POSIX "printf()".

#### Нестатические методы

* `void Replace( String pattern, String replacement )`: заменить все подстроки.
* `String Left( int len )`: обрезать строку с начала и до <len>.
* `String Mid( int pos = 0, int len = 2147483647 )`: вырезать кусочек строки с <pos> количеством <len>.
* `void Truncate( int newlen )`: обрезать строку (равноценно "`Left()`"?).
* `void Remove( int index, int remlen )`: удалить <remlen> символов с позиции <index>.
* `String CharAt( int pos )`: получить символ по указанной позиции.
* `int CharCodeAt( int pos )`: получить ACSII-код символа по указанной позиции.
* `String Filter()`: применить фильтр escape-последовательностей (см. ниже).
* `int IndexOf( String substr, int startIndex = 0 )`: найти первое вхождение подстроки в строку, начиная с <startIndex>.
* `int LastIndexOf( String substr, int endIndex = 2147483647 )`: найти последнее вхождение подстроки в строку не дальше <endIndex>.
* `void ToUpper()`, `void MakeUpper()`: изменить регистр всех букв в строке на верхний.
* `void ToLower()`, `void MakeLower()`: изменить регистр всех букв в строке на нижний.
* `int ToInt( int base = 0 )`: попытаться сконвертировать строку в тип `int` с основанием системы счисления <base>.
* `double ToDouble()`: попытаться сконвертировать строку в тип `double`.
* `void Split( out Array<String> tokens, String delimiter, EmptyTokenType keepEmpty = TOK_KEEPEMPTY )`: разбить строку по делителям <delimiter>, поместив результат в массив строк <tokens>.

_С не кодировками ANSI могут наблюдаться проблемы с позицией символов, так как тот же Unicode содержит символы нефиксированной байтовой длины._



## Escape-последовательности

Практически совпадают со стандартом C.

* “`\n`”: перевод на следующую строку.
* “`\x##`”: запись символа по его шестнадцатеричному представлению.
* “`\o###`”: запись символа по его восьмеричному представлению.
* “`\c#`”: изменение цвета последующих символов; вместо “#” должен быть любой из этих символов _(тут должна быть ссылка на zdoom.org/wiki)_.
* “`\c[<color>]`”: изменение цвета последующих символов; вместо “\<color\>” должно стоять название, объявленное в “x11r6rgb.txt”.

Для изменения цвета есть также строковые константы в классе `Font` — достаточно работать с ними как с обычными строками и, например, конкатенировать их с тем, с чем нужно:

```C
const MsgCol = TEXTCOLOR_GRAY; // Основной цвет какой-то нашей надписи. Пусть серой будет.
const MsgSep = MsgCol .. ", "; // Оформленный разделитель, для удобства вынесенный в константу — запятая серого цвета.

console.printf( MsgCol .. "You must find " .. TEXTCOLOR_RED .. "scarlet-red" .. MsgSep .. TEXTCOLOR_CYAN .. "murky" .. MsgSep .. TEXTCOLOR_GOLD .. "gold" .. MsgCol .. " and " .. TEXTCOLOR_GREEN .. "forest" .. MsgCol .. " keys." );
```



## Типы данных, похожие на строки

А также комментарии к ним.

* `Sound`: узкоспециализированный тип строки: путь до звука, прописанный в lump SNDINFO. Автоконвертация String в Sound будет сделана там, где это надо; то есть вместо него практически всегда можно использовать обычный String.

* `Name`: технически является `uint`, а не строкой, поэтому преобразовывать туда-сюда выйдет не всегда.

* `StateLabel`: название стейта (см. Actor). Противоречивый тип данных, так как конвертация возможна, но при определённых условиях. Произвольную строку в этот тип загрузить не удастся.

* `TextureID`: технически также `uint`, автоконвертацию можно провести только из него в `String`, но не наоборот. Для обратного преобразования см. [ссылка на статью], а также исходник "base.txt:TexMan.CheckForTexture()".

