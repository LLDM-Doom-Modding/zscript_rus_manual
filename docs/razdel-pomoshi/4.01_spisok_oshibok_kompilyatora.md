---
description: Ошибки при компиляции и варианты их решения.
---

# Ошибки компиляции

## Ошибки синтаксиса

"`Unexpected '<строка>'`": ошибка в синтаксисе, вместо указанной строки компилятор ожидал встретить что-то другое. Сообщение встречается в совершенно разных ситуациях, так что точнее сказать ничего не могу. Единственное что, если на месте строки стоит знак равенства, то, возможно, была попытка инициализации глобальной переменной.

"`Unexpected character: <символ> (ASCII <код>)`": в коде ZScript нельзя использовать символы, которые не принадлежат латинскому алфавиту, цифрам или международным знакам пунктуации. К комментариям это не относится.

"`Invalid global identifier '<идентификатор>'`": в текущем классе нет такого идентификатора: ни поля, ни константы, ни метода.

"`Unknown identifier '<идентификатор>'`": в вызываемом классе нет такого идентификатора.

"`Unknown function <имя_метода>`": в вызываемом классе нет такого метода (от предыдущего компилятор отличает наличием в коде скобок после идентификатора).

"`Function '<имя_метода>' used without ().`": вызывается существующий метод, а скобки забыты.

"`Compound initializer not implemented yet`": пока что инициализировать массивы значениями сразу (через "`= { <знач1>, <знач2>, ... };`") нельзя.

* "`<имя_переменной>: Map types not implemented yet`": похоже, плюс-минус то же самое.

"`Invalid expression on left hand side of <имя>`": не удалось разобрать выражение слева от указанного слова.

"`Invalid qualifiers for <имя> (<модификатор(-ы)> not allowed)`": некоторые ключевые слова-модификаторы (см. 2.09 "Модификаторы переменных и методов") нельзя использовать в объявлении классов, структур, методов и полей.

## Ошибки переменных, констант, массивов и типов

"`Expression must be a modifiable value`": указанная переменная открыта только для чтения. Возможно, она помечена как `readonly` или `meta` (см. 2.09 "Модификаторы переменных и методов") или произошло вторжение в запрещённую сферу влияния (см. 2.08 "Сферы влияния").

"`Cannot convert <тип_1> to <тип_2>`": попытка присвоить несовместимый тип. Например, присвоение указателю какого-то числа, или массиву — какой-то строки.

"`Numeric type expected`": фактически, тот же "Cannot convert...", но с уточнением, что конечный тип принадлежит множеству чисел. Встречается при указании индекса массива не целочисленным значением, а также в попытке передать не число в числовое свойство.

"`Cannot convert to string`": то же самое, но на этот раз не удалось привести к строке. Проще всего это обойти, добавив принудительную конкатенацию с пустой строкой: "`"" .. <нестроковый_идентификатор>`" (см. 1.08 "Строки").

"`Array index out of bounds`": константное значение индекса статического массива лежит вне его пределов. Не стоит забывать, что нумерация в них всегда начинается с нуля и всегда заканчивается значением `n - 1`, а не `n` (см. 1.09 "Массивы").

"`Must specify array size`": забыто указание размера массива (см. 1.09 "Массивы")?

"`Array index must be an integer constant`": размер массива должен быть объявлен натуральным числом (целым, больше единицы) (см. 1.09 "Массивы").

* "`Array size must be positive`": комментарий тот же.

"`Cannot cast a readonly pointer`": указатели, объявленные как "Только для чтения", из соображений безопасности невозможно привести к какому-либо другому типу (см. 2.07 "Указатель на класс, шаблоны "class<>" и "readonly<>").

"`<имя_переменной>: Array type not allowed`": указывать в качестве типа динамического массива другой динамический массив нельзя (см. 1.09 "Массивы") _(уточнить пояснение)_.

"`<тип> does not represent a class type`":

"`Unable to resolve <идентификатор> as type`": невозможно определить принадлежность типа к какому-либо классу.

"`Invalid type`": внутренняя ошибка распознавания, тип переменной оказался неизвестным. Интересно, какими же извращениями она у Вас появилась.

"`<имя_переменной>: Base type for dynamic array types must be integral, but got <тип>`": указанный тип для динамического массива оказался слишком сложным. Например, другой динамический массив.

"`Internal error when generating code for array access`": ошибка появлялась на старых версиях при попытке проложить маршрут в динамический массив из-под другого динамического массива (см. 1.09 "Массивы", подраздел "Многомерный динамический массив").

"`<имя> is not a constant`": указанный идентификатор не является константой там, где это нужно.

"`Enum members must be integer values`": попытка присвоить элементу перечислимого типа значение с плавающей точкой (см. 1.04. "Константы и перечисляемые типы").

* "`Bad type for constant definiton`": то же, но с любым другим типом.

"`Initializer must be constant`": инициализация статического константного массива должна производиться также при помощи констант (см. 1.09 "Массивы", раздел "Статический массив" _(впоследствии, скорее всего, будет перенесено)_).

"`Non-integral type in constant array`": в инициализации статического константного массива могут быть лишь целые числа, числа с плавающей точкой, неизменяемые указатели и строки.

## Ошибки методов

"`All arguments after the first optional one need also be optional`": обязательный аргумент появился после аргумента со значением по умолчанию (см. 1.10 "Методы", подраздел "Синтаксис").

"`Too many arguments in call to <имя_метода>`"/"`Insufficient arguments in call to <имя_метода>`": количество переданных в метод аргументов больше/меньше того, что метод может принять.

"`The return type of a function cannot be a dynamic array`": возвращаемым типом не может быть динамический массив. Увы.

## Ошибки специальных ключевых слов и конструкций

#### Default-блок и другие ключевые слова для класса Actor

_Где не указано обратное, см. 2.04._

"`Non-actor classes may not have defaults`": класс не наследован от `Actor`, в нём невозможно использовать специфичный блок "`Default {}`".

"`<имя_класса> already has defaults`": `Default`-блок указан дважды.

"`@property@<имя_класса>.<имя_свойства>' is an unknown actor property`": такого свойства не существует у указанного актора. Если свойство создано пользователем, то, возможно, забыт префикс класса (просто "MyProperty" вместо "MyClass.MyProperty").

"`Replaced type '<имя_замены>' not found for <имя_заменяемого_класса>`": не найден класс, на который предлагается заменить данный.

"`Variable <имя_переменной> not found in <имя класса>`": не найдена связанная переменная для добавляемого свойства или флага.

"`Argument count mismatch: Got <фактическое_количество>, expected <ожидаемое_количество>`": ошибка в количестве аргументов у свойства.

"`Unable to add property <название_свойства> to class <имя_класса>`": скорее всего, свойство с таким же именем уже есть в классе.

"`'<имя_свойства>' requires an actor of type '<имя_класса>'`": в качестве аргумента свойства передан несовместимый класс.

"`Properties can only be defined for actors`": класс не наследован от `Actor`, в нём невозможно объявить свойство.

"`<имя_свойства>: arguments missing`": похоже, пропущены какие-либо аргументы для свойства.

"`<имя_свойства>: non-constant parameter`": в качестве аргумента для свойства передана переменная.

"`unhandled property type <тип_переменной>`": попытка использовать в качестве свойства неподдерживаемый тип переменной. Простейший пример — типы "voidptr" или "PlayerPawn".

"`class <имя_класса> is not compatible with property type <тип_переменной>`":

"`Property name may at most contain two parts`":

"`Flags can only be defined for actors`": класс не наследован от `Actor`, свои `flagdef` объявить в нём нельзя.

"`Variable <имя_переменной> in <имя_класса> must have a size of 4 bytes for use as flag storage`": длина переменной, используемой для связывания с пользовательским флагом, должна быть равна ровно четырём байтам (см. 1.02. "Основные типы данных").

"`Flag name may at most contain two parts`":

"`Unknown flag '<имя_флага>'`": указанного флага не существует.

"`Unable to add flag <название_флага> to class <имя_класса>`": скорее всего, флаг с таким же именем уже есть в классе.

_"`Unknown Action qualifier`": неизвестное action-определение (`SUF_ACTOR`/`SUF_OVERLAY`/`SUF_WEAPON`/`SUF_ITEM`)._

"`'Action' can only be used in child classes of Actor`": нельзя использовать ключевое слово `action` в классах, не наследованных от `Actor`.

"`Action functions cannot be declared const`": нельзя объявлять `action`-функции константными.

* "`Action functions cannot be declared UI`": то же, но с модификатором `ui`.

#### Сферы влияния

"`Invalid combination of scope qualifiers <модификатор(-ы)> on field <имя>`": нельзя одновременно назначать более одного модификатора из "`play`", "`ui`" и "`clearscope`" (см. 2.09 "Модификаторы переменных и методов").

"`Can't call <сфера_вызываемого> function <имя_метода> from <сфера_вызывающего> context [<примечание>]`": нарушение сфер влияния, невозможно вызвать одно из-под другого; см. 2.08 "Сферы влияния".

"`Can't change class scope in class <имя_класса>`": назначить иную сферу влияния классу, у которого она уже не нейтральна (который уже не просто данные), нельзя — см. 2.08 "Сферы влияния".

#### Остальное

"`Unknown native class <имя_класса>`": использовано ключевое слово "`native`" для пользовательского класса (см. 2.09 "Модификаторы переменных и методов").

* "`The function '<имя_метода>' has not been exported from the executable`": то же, но для пользовательского метода.
* "`The member variable '<имя_переменной>' has not been exported from the executable.`": то же, но для пользовательской переменной.

"`<имя_класса> is not a native class`": класс, использованный в качестве . Ключевое слово "`native`" в пользовательских скриптах не имеет смысла.

"`'VarArg' can only be used with native methods`": модификатор "`vararg`" невозможно использовать в пользовательских файлах, см. 2.09 "Модификаторы переменных и методов".

"`<идентификатор>: @ not allowed for user scripts`": использовано ключевое слово "`@`" для пользовательского поля (см. 2.09 "Модификаторы переменных и методов").

"`Native meta variable <имя_переменной> not allowed`": запрещено одноременное использование модификаторов "`native`" и "`meta`".

"`The member variable '<имя_класса>.<имя_поля>' has not been exported from the executable.`": поле, объявленное как `native`, не было найдено в исходном коде (см. 2.09 "Модификаторы переменных и методов").

"`The member variable '<имя_класса>.<имя_поля>' has mismatching sizes in internal and external declaration. (Internal = <внутренняя_размерность>, External = <внешняя_размерность>)`": поле, объявленное как `native`, имеет размерность, отличающуюся от оной в исходном коде.

"`Cannot add field <имя_поля> to <имя_класса>. <имя_класса> has native children which means it size may not change`": нельзя использовать ключевое слово `meta` в классе, от которого наследуется хотя бы один класс, помеченный как `native`.

"`Cannot declare non-native global variables. Tried to declare <имя>`": переменные (не константы) объявлять вне классов и структур нельзя.

## Ошибки, связанные с ООП

"`Class name <название_класса> already exists`": класс с таким именем уже существует.

"`Class <дочерний_класс> has unknown base class <родительский_класс>`": класса, указанного как родительский, не существует.

"`Class <имя_класса> has circular inheritance`": несколько классов не могут циклически наследоваться друг от друга.

"`Class <имя_класса> cannot be found in the current translation unit.`":

"`Cannot define native structs inside classes`":

"`Struct <имя_структуры> has incompatible flags`": скорее всего, в структуре одновременно использованы ключевые слова "`ui`" и "`play`".

* "`Class <имя_класса> has incompatible flags`": то же, дновременно установлены несколько конфликтующих ключевых слов.

"`Qualified name '<имя>' for base class not supported in '<имя>'`":

"`Parent class <имя_родительского_класса> of <имя_класса> not accessible to ZScript version <версия_языка>`":

"`Attempt to redefine '<имя>'`": попытка переопределения уже существующего идентификатора.

"`Invalid combination of qualifiers <модификатор_1>, <модификатор_2> on function <имя_метода>`": несовместимые модификаторы для метода. Например, объявление его одновременно статическим и виртуальным (см. 1.13).

"`Function <имя_метода> attempts to override parent function without 'override' qualifier`": попытка объявления нового метода с тем же названием вместо переопределения уже существующего виртуального (см. 1.13). Забыто слово "`override`"?

"`Attempt to override non-existent virtual function <имя_метода>`": переопределяемого метода компилятор не нашёл; чаще всего ошибка появляется из-за того, что в переопределении не совпадают типы параметров или их количество.

"`Cannot initialize non-scalar variable <имя_переменной> here`": некоторые типы переменных (в частности, пользовательские структуры) нельзя объявлять в качестве локальных.

"`Abstract method must be overrided`" _(уточнить; для ver. >= 3.4.0?)_: в дочернем классе необходимо переопределить все абстрактные методы родителя, см. 1.13 "Виртуальные методы, абстрактные классы/методы".

## Другие ошибки

"`Include script lump <путь> not found`": не удалось найти указанный в директиве `#include` файл (см. 1.05 "Синтаксис препроцессора").

"`Class <имя_класса> not accessible to ZScript version <версия>`": класс недоступен в указанной версии ZScript.

"`<встроенный_метод> requires an object`": попытка вызова встроенного метода для объектов для чего-то другого (например, структуры).

* "`<встроенный_метод> requires an actor class type`": то же, но ожидался актор.

"`Unable to resolve all fields for class <имя_класса>`": констатация факта ошибки разбора указанного класса. Появляется после некоторых других сбоев при компиляции.

* "`Unable to resolve all fields for struct <имя_структуры>`": то же, но для структур. Теоретически конкретно такая ошибка не может появиться никогда.
