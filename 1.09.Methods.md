# Методы

ZScript по своим синтаксическим структурам очень напоминает C++ или C#: такое же объявление переменных, функций, похожее внутреннее наполнение. В случае, если Вы изучали Си, C++, C#, Java, JavaScript и другие Си-подобные языки, или же если Вы знаете Decorate с anonymous-функциями или ACS, разобраться с представлением кода на ZScript не составит труда.



## Определения

Функция — описание какого-либо поведения, может принимать значения в качестве параметров и возвращать результат.

Можно попробовать провести параллель с функцией в математике. Это закон-замена одного значения другим, вычисленным по определённым правилам ("Отображение одного множества на другое", если вспомнить университетский курс). А в программировании? Подпрограмма, которая может принимать на вход значения, что-то с ними внутри делать, и выдывать обратно уже иной, обработанный результат. Чего-то напоминает, нет?

Метод в ООП — это функция, объявленная внутри структуры с данными. В ZScript функции вне классов/структур объявлены быть не могут, так что там всё — методы.

В объявлении функции/метода в языках программирования, и в ZScript в частности, должны присутствовать входные и выходные типы данных.

_Примечание **N00b2015**: В данных же фактически вся суть, а здесь "должны", как будто это какое-то ограничение._



## Синтаксис

Обычно следующего синтаксиса достаточно:

```C
<возвращаемый_тип> <название_метода>( [<аргтип1> <аргумент1 [= <умолчание1>]>[, <аргтип2> <аргумент2 [= <умолчание2>]>[...]]] ) {
	<тело_метода>

	[return <возвращаемое_значение>;]
}
```

`<возвращаемый_тип>`, `<аргтип1>`, `<аргтип2>` и так далее должны быть любыми существующими поддерживаемыми типами данных, совершенно не обязательно одинаковыми. Целое число, вещественное число, булево значение, строка, 2D- и 3D-векторы, нативная структура вроде `CVar` (см. 2.01), указатель на любой объект, любой встроенный или собственный класс — всё это понимается парсером.

`<название_метода>` не должно быть идентичным названию какого-то другого метода или какой-либо переменной в том же или родительском классе (см. наследование в 1.11). Если будут две функции "`Print()`", то компилятор попросту не поймёт, какую из них нужно использовать в каждом месте вызова.

`<аргумент1>`, `<аргумент2>` и так далее — аргументы, они же параметры функции, они же локальные переменные. Переданные откуда-либо снаружи значения в них можно использовать внутри тела метода. **Сами внешние переменные при этом не меняются**!

`<умолчание1>`, `<умолчание2>` и так далее — значения локальных переменных по умолчанию. Параметры с ними — так называемые опциональные аргументы — должны идти после всех обязательных для передачи полей.


### Примеры

```C
// Возвращает знак числа:
//  "1", если положительное;
//  "0", если равно нулю; и
//  "-1", в иных случаях (если отрицательное).
int sign( int value ) {
	if ( value > 0 )
		return 1;

	if ( value == 0 )
		return 0;

	return -1;
}
```

Пример функции без возвращаемого значения:

```CPP
// Выводит в консоль указанное сообщение (<message>).
// Если сообщение не критическое (<fatal> == false), то цвет сообщения будет серым, иначе — красно-жёлтым.
void MyLog( String message, bool fatal = false ) {
	if ( fatal )
		console.printf( TEXTCOLOR_GRAY .. "MyLog(): " .. message );
	else
		console.printf( TEXTCOLOR_RED .. "!!! MyLog() fatal\c-: " .. TEXTCOLOR_FIRE .. message );
}

// Вызов:

MyLog( "Just message." );
MyLog( "An error! Maybe...", true );
MyLog( "Another non-fatal text.", false );
```



## Дополнительный функционал ZScript

ZScript имеет несколько интересных особенностей, связанных с вызовом функций.

### Возврат более чем одного значения



### Именованные параметры

Иногда требуется передать в функцию какой-либо опциональный аргумент, который находится где-то в самом конце. Для примера возьмём встроенную функцию "`A_SpawnItemEx()`" (создать на уровне указанного актора с заданными координатами, скоростью, наклоном, параметрами и TID. И да, в ней как раз используется возврат двух значений сразу):

```CPP
Actor, bool A_SpawnItemEx( class<Actor> itemtype, double xofs = 0, double yofs = 0, double zofs = 0, double xvel = 0, double yvel = 0, double zvel = 0, double angle = 0, int flags = 0, int failchance = 0, int tid = 0 );
```

Пусть у нас будет создаваться дымок от выстрела. И поэтому, например, нам необходимо задать этому актору только вертикальную скорость и шанс появления — все остальные аргументы в данном случае нам просто не нужны.

Для того, чтобы добраться до них, мы можем, конечно, методично переписывать значения по умолчанию. Но читать это довольно трудно:

```CPP
// Устанавливаем только "xvel" и "failchance":
A_SpawnItemEx( "ExampleShootSmoke", 0, 0, 0, 0, 0, 3.5, 0, 0, 63 );
```

Но проще воспользоваться передачей именованного аргумента:

```CPP
A_SpawnItemEx( "ExampleShootSmoke", xvel: 3.5, failchange: 63 );
```

Благодаря этому сразу становится видно, какие конкретно параметры мы передаём.

### Передача переменной, а не её значения

Оно же "ссылка" в C++, оно же "передача указателя на переменную" в C (ну, плюс-минус).

Периодически возникает необходимость оперировать не над переданными данными, а над тем, что хранит эти самые данные (простой учебный пример — обмен местами значений в двух переменных). Для такого случая в ZScript существует ключевое слово "`out`", прописывающееся перед типом переменной:

```CPP
void ExchangeInts( out int var1, out int var2 ) {
	int temp = var1;
	var1 = var2;
	var2 = temp;
}
```

В этом случае поменяются не локальные копии переменных, а то, что было передано:

```CPP
int a = -3;
int b = 9876;

console.printf( "a: " .. a .. ", b: " .. b ); // "a: -3, b: 9876";
ExchangeInts( a, b );
console.printf( "a: " .. a .. ", b: " .. b ); // "a: 9876, b: -3".
```

На этот функционал есть два ограничения: во-первых, нельзя использовать значения по умолчанию, во-вторых, нельзя передавать по такому аргументу константное значение.

```CPP
void FalseExchanging( out int var1, out int var2 = 5 ) { // Ошибка компиляции.
	int temp = var1;
	var1 = var2;
	var2 = temp;
}

ExchangeInts( 5, 3 ); // Ошибка компиляции: у констант нет адреса, куда писать, откуда брать?
```
