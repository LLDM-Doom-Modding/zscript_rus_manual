Добро пожаловать в цикл разборов скриптового языка для (G)ZDoom-совместимых портов — ZScript!

## Краткое описание ZScript

Началом истории ZScript можно считать 20 июля 1999, когда сообщество игроков узнало о планах создателя порта ZDoom Randy Heit на включение в порт, которому тогда было чуть больше года, универсального скриптового языка DoomScript, позволивший бы компенсировать недостатки ACS и расширить возможности для создания игровых модификаций. Эта идея послужила мощным толчком к развитию порта, в частности, благодаря ней появился и постепенно обрёл свой нынешний облик язык Decorate. Однако несмотря на обилие возможностей, привнесённых в Decorate за это время, он так и остался языком, основная задача которого — описание внутриигровых взаимодействий между акторами; доступ к другим данным, например, геометрии уровня или меню, с его помощью получить очень трудно. Тем не менее, через многие годы мечты многих разработчиков об удобном универсальном языке наконец воплотились в виде ZScript, о котором дальше и пойдёт речь.

Как язык он появился ещё в так и не вышедшей версии ZDoom 2.9.1. Тогда он представлял из себя Decorate-подобный набор функций с чуть более расширенными возможностями. Graf Zahl (разработчик GZDoom) подхватил идею и развил её, сильно приблизив скрипт к аналогичному в Unreal Engine и C#.

По визуальному представлению он не сильно отличается от ООП-языков типа C++, C# или Java. Все основные синтаксические формы в ZScript взяты со стандарта C++/Java. В нём нет различия меж строчными и заглавными буквами - регистр букв в коде игнорируется.

ZScript — вещь довольно мощная; в наиболее известной линейке языков, посвящённых Doom -- DeHackEd, ACS, Decorate, ZScript - он является самым гибким. Технически является сырым API [https://ru.wikipedia.org/wiki/API] к движку — без глубоких проверок на ошибки и с относительной свободой действий в пределах самого движка. Функционалом своим сильно превосходит Decorate и, естественно, DeHackEd. Может почти полностью, за исключением крайне редких специфических случаев, заменить собой ACS, но не наоборот. Кстати, довольно мощной является и их связка — ZScript + ACS — так как из-под любого из них можно вызывать код другого, они прекрасно дополняют друг друга. Также сюда хотелось бы сразу добавить ответ на довольно популярный вопрос: "Что загружается раньше, Decorate или ZScript"? Ответ — и тот, и другой компилируются в общий байт-код, но ZScript парсится раньше; соответственно, можно сделать класс на нём и затем использовать его в Decorate-коде. Обратно — не выйдет.

## Комментарии

Самая полезная вещь в любом языке программирования — это комментарии. Они будут помогать везде в последующих разборах. Они позволяют прояснить непонятные моменты, временно убрать часть пока что ненужного кода, да и просто не забыть, что происходит на данном конкретном участке, если возвращаешься к программе эдак года через два! И ZScript — не исключение. Он предоставляет два варианта обозначения того, что текст — комментарий. Оба эти варианта пришли с незапамятных времён — многострочный со стандарта C89 [http://port70.net/~nsz/c/c89/c89-draft.html], однострочный — с C99 [http://port70.net/~nsz/c/c99/n1256.pdf] (хотя использовался и ранее, примерно с 90-го года).

```C
// Так будут обозначаться однострочные комментарии (игнорируются препроцессором до конца строки);

/*  Так -- многострочные комментарии (также 
   игнорируются, но по всей длине, до закрывающей 
   последовательности символов); */
```

К слову: хорошим тоном считается, когда программа (или, в нашем случае, скрипт) самозадокументирована. Иначе говоря, когда любую логически обособленную часть кода сможет понять отдельно от других. А тут без комментариев не обойтись...


## Основная номенклатура

ZScript является объектно-ориентированным языком, и из ООП на него распространяются и парадигмы [https://www.insight-it.ru/theory/2008/tri-osnovnyx-komponenta-paradigmy-obektno-orientirovannogo-programmirovaniya/], и понятия [https://habr.com/ru/post/87119/]. Перечислим основные из них (иные будут представлены в соответствующих разделах):

* Класс: шаблон/штамп/описание/нечто неизменяемое. По классу создаются копии объектов. В классе лежит вся информация о том, что конкретно будет содержатся в объектах (различные переменные) и как оно будет взаимодействовать (функции, которые в ООП называются методами).
* Объект (экземпляр класса): динамическая, "живая" копия класса. Является основным "действующим лицом" в ООП — если учесть, что клонировать их даже с одного класса можно сколь угодно много (...пока памяти хватает). То есть класс — форма для заливки, описание; объект — взаимодействие, динамика.
* Наследование: использование одного класса в качестве "родителя" другого, с сохранением в дочернем классе всех свойств (переменных, методов) родительского, но и с добавлением своих. С помощью данной парадигмы выстраиваются целые иерархии и деревья классов — довольно удобно.
* Полиморфизм: возможность изменять некоторые свойства родителей в дочерних классах. Даёт б**о**льшую гибкость иерархии.
* Инкапсуляция: обеспечение принципа "вещи-в-себе" - цельности объекта по данным и коду, работающему с ними; также предоставляет полуавтоматическую защиту от несанкционированного доступа к объектам ("кто и как может работать со мной").

## Заключение к введению

По своему опыту и я, и другие известные люди, разбирающиеся в ZScript (лично спрашивал) установили, что два лучших способа понять, как работает та или иная функция — это посмотреть на примерах в g-/l-/qzdoom.pk3 и взглянуть на исходный код G-/L-/QZDoom. Данный цикл статей не сможет и, по задумке автора, не собирается охватывать весь ZScript, так как последний слишком часто меняется (однако для большинства задач даже старой версии 2.4.0 должно хватать за глаза и по уши). Так что не стоит считать, что информация, хранящаяся внутри \*.pk3 или в исходном коде, не нужна обычному моддеру. Например, исходники незаменимы, если требуется понять значения параметров, которые используются в "нативных" (вшитых напрямую из C++-кода) функциях, или заставить их работать "неправильно", но так, как нужно Вам.

* * *

Удачи в изучении ZScript!
