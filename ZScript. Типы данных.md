Тип переменной является прямым указанием процессору, в нашем случае — движку, как ней нужно будет работать — как с целым числом, как со строкой, как с указателем на класс, как с указателем на вещественное число, как с… В общем, типов данных предостаточно, и каждый из них предназначен и оптимизирован для своего действия; хотя, конечно, никто не запрещает работать и на смежных территориях — например, в целых значениях через вещественные числа.

Итак: какие же основные типы данных есть в ZScript?

## Работа с числами

Основной арсенал похож на аналогичный в C++ с некоторыми изменениями.

_Внимание моддерам на ACS: типа «fixed» в ZScript нет, а битовые операции с double ничем хорошим не закончатся (см. стандарт IEEE 754 [https://www.softelectro.ru/ieee754.html], по ссылке — §5)._

```C
int
//  Самый известный тип, целочисленный: переменные, 
//объявленные как int (сокращение от "integer"), 
//могут иметь только целочисленные значения в 
//диапазоне от -2,147,483,648 до 2,147,483,647.
//  Занимает четыре байта памяти.

uint
//  Беззнаковый аналог целочисленного типа, 
//сокращение от "unsigned int". Умеет работать 
//только на множестве натуральных чисел с нулём. 
//Диапазон -- от 0 до 4,294,967,295. 
//  Объём -- также четыре байта.
```

```C
double
//  Вещественный тип, позволяет хранить дробные 
//числа с более-менее неплохой точностью. Диапазон
//возможных значений в максимумах -- 
//от -1.7 * 10^308 до 1.7 * 10^308, 
//допустимый минимум -- 1 * 10^(-308).

//  При взятии остатка от деления по модулю ("%") 
//происходит автоконвертация в int с округлением 
//до ближайшего целого.
```

```C
bool
//  Логический тип. Технически, однобайтовый int 
//со значением либо ноль ("0" и есть), либо не-ноль
//(любое ненулевое число, обычно используется "1").

//  Есть более правильные аналоги "0"/"1" для 
//логического типа -- это константы "false" и "true" 
//соответственно (см. "Алгебра логики").
```

Далее перечислены числовые типы, которые существуют в ZScript, но которые без чёткого понимания использовать не рекомендуется.

```C
int8, int16
// Знаковые целочисленные с изменённой битностью. 
// В int8 восемь бит, то есть один байт, значения -- от -128 до 127.
// В int16 -- 16 бит (два байта), диапазон -- от -32768 до 32767.

uint8, uint16
// Беззнаковые целочисленные изменённой физической длины.
// uint8:   1 байт, диапазон -- от 0 до 255.
// uint16: 2 байта, диапазон -- от 0 до 65535.

float
//  Хронологически изначальный тип вещественных чисел; по сравнению 
//с диапазоном double -- укорочен раза в два. В ZScript оставлен 
//ради обратной совместимости со старыми версиями Decorate.
//  Возможные значения: ±-3.4 * 10^(±-38).

sint4
// Технический тип данных, изредка промелькивал в сообщениях об 
//ошибках. Невозможно объявить, диапазон -- от -8 до 7?```
```

## Строки + производные от строк типы

Работа со строками в рассматриваемом языке представлена довольно обширно. Присутствует конкатенация (объединение строк), преобразование почти любых иных типов в строку, замена подстрок, локалзиация и так далее.

```C
String
// Строковый тип. В длине ограничен максимально фрагментом 
//нераспределённой памяти (читай: "на практике -- не ограничен").

Name
// Фактически, узкоспециализированная строка, заточенная под названия
//классов. Можно использовать обычную строку (зачастую она и 
//используется), ZScript сам сконвертирует общий строковый тип в 
//правильный.
// Он же -- "class<тип>".

Sound
// Также узкоспециализированный тип строки: путь до звука, прописанный
//в lump'е SNDINFO. Автоконвертация String в Sound там, где это надо,
//будет сделана; то есть, аналогично предыдущему, вместо него можно 
//практически всегда использовать и String.
```

## Указатели на экземпляры классов

Указатели служат, как можно понять по названию, для указания процессору, с каким конкретно объектом ему нужно работать. Фактически, количество типов указателей неограничено, так как любой новый написанный класс уже порождает тип указателя. Так что здесь, ниже, приведены самые основополагающие из них.

```C
Actor
// Указатель на объект типа "Actor". Как раз акторами и являются все
//объекты в игровом мире -- игроки, монстры, оружие, декорации, 
//файерболы, дымок от пуль, источники динамического света и так далее.
// Класс "Actor" наследуется от класса "Thinker".

Thinker
// Thinker -- любой объект, имеющий право хоть как-то взаимодействовать
//с миром. Это, собственно, все акторы, эффекты секторов, "сущности" 
//ботов, декали, маркеры автокарты и иные объекты, прямо или косвенно
//связанные с игровым миром.
// Наследуется от "Object".

Object
// Разработчики ZScript решили всех запутать и сделали класс c названием
//"Object". Фактически это просто удобная оболочка для мира для 
//стандартного "пустого" класса.

ThinkerIterator
ActorIterator
// Вспомогательные объекты, позволяют перебрать всех Thinker'ов в мире,
//удовлетворяющих фильтру наследования.

BlockThingsIterator
BlockLinesIterator
// Вспомогательные объекты, используются для перебора всех блокирующих
//линий или акторов вокруг определённого актора или определённой позиции
//в мире.```

```C
// Дерево наследований объектов мира (далеко не все, представленные 
//здесь, разобраны -- это не нужно поначалу; но когда Вам всё-таки 
//понадобится работа на таком низком уровне -- уверен, Вы уже будете
//понимать устройство ZScript).
// Через "<...>" обозначены используемые реже и не основные встроенные
//классы. На наследование самописных это никак не влияет.

Object

  Thinker
    Actor
      Inventory        // Базовый класс инвентаря.
        StateProvider
          CustomInventory
          Weapon       // Базовый класс оружия.
            <...>
        Powerup        // Базовый класс powerup'ов.
          <...>
        PowerupGiver
        <...>
      <...>
    SectorEffect
      Lighting
      Mover
        MovingFloor
          Floor
        MovingCeiling
          Ceiling
    <...>

  ThinkerIterator
  ActorIterator
  BlockThingsIterator
  BlockLinesIterator

  <...>
```

## Структуры построения уровня: линии, секторы, вершины

В этом разделе представлены лишь главные и самые используемые составляющие структур постороения уровней — в случае нужды все остальные есть и в g-/q-/lzdoom.pk3. 

Вершина («Vertex») имеет в себе лишь свою неизменяемую позицию:

```Csharp
native readonly Vector2 p;
```

Сторона линии («Side») уже гораздо более интересна.

```Csharp
native readonly Sector sector;  // Сектор, на который выходит эта сторона.
native readonly Line linedef;   // Линия, которой принадлежит эта сторона.
native int16    Light;          // Уровень освещённости стороны.
native uint8    Flags;          // Флаги стороны.

native TextureID GetTexture(int which);  // Функция, позволяющая получить id текстуры на этой стороне.
native clearscope Vertex V1();  // Функция, возвращающая указатель на первую вершину для стороны.
native clearscope Vertex V2();  // Функция, возвращающая указатель на вторую вершину для стороны.
native int Index();             // Функция, возвращающая индекс стороны.
```

Линия («Line»):

```Csharp
```

Сектор («Sector»):

```Csharp
```

## Иные типы

Здесь вкратце описаны основные (не все) встроенные типы, которые возможно использовать в качестве типов переменных для своих проектов. Остальные — типа LevelLocals, отвечающей за все данные уровня — использовать как тип своей переменной нерационально, за исключением прямо-таки невероятно редких случаев.

```Csharp
vector2
// Составной тип, радиус-вектор на декартовой плоскости. Имеет в себе
//две переменных типа "double" -- "x" и "y".

vector3
// Составной тип, радиус-вектор в пространстве. Имеет в себе три
//переменных типа "double" -- "x", "y" и "z". Один из самых используемых
//для расчётов и позиционирования в игровом мире.

CVar
// Внешняя переменная, записываемая в конфигурационный файл.

Font
// Структура, отвечающая за шрифты внутри игры.

TextureID
// Идентификатор текстуры, её смещение в памяти.
```