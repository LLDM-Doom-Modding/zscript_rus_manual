Добро пожаловать в цикл разборов скриптового языка для (G)ZDoom-совместимых портов — ZScript!

## Краткое описание ZScript

Началом истории ZScript можно считать 20 июля 1999, когда сообщество игроков узнало о планах создателя порта ZDoom Randy Heit на включение в порт, которому тогда было чуть больше года, универсального скриптового языка DoomScript, позволивший бы компенсировать недостатки ACS и расширить возможности для создания игровых модификаций. Эта идея послужила мощным толчком к развитию порта, в частности, благодаря ней появился и постепенно обрёл свой нынешний облик язык Decorate. Однако несмотря на обилие возможностей, привнесённых в Decorate за это время, он так и остался языком, основная задача которого — описание внутриигровых взаимодействий между акторами; доступ к другим данным, например, геометрии уровня или меню, с его помощью получить очень трудно. Тем не менее, через многие годы мечты многих разработчиков об удобном универсальном языке наконец воплотились в виде ZScript, о котором дальше и пойдёт речь.

Как язык он появился ещё в так и не вышедшей версии ZDoom 2.9.1. Тогда он представлял из себя Decorate-подобный набор функций с чуть более расширенными возможностями. Graf Zahl (разработчик GZDoom) подхватил идею и развил её, сильно приблизив скрипт к аналогичному в Unreal Engine и C#.

Технически ZScript является сырым API [https://ru.wikipedia.org/wiki/API] к движку — без глубоких проверок на ошибки и с относительной свободой действий в пределах самого движка. Функционалом своим сильно превосходит Decorate и, естественно, DeHackEd. Может почти полностью, за исключением крайне редких специфических случаев, заменить собой ACS, но не наоборот. Кстати, довольно мощной является и их связка — ZScript + ACS — так как из-под любого из них можно вызывать код другого, они прекрасно дополняют друг друга. Также сюда хотелось бы сразу добавить ответ на довольно популярный вопрос: "Что загружается раньше, Decorate или ZScript"? Ответ — и тот, и другой компилируются в общий байт-код, но ZScript парсится раньше; соответственно, можно сделать класс на нём и затем использовать его в Decorate-коде. Обратно — не выйдет.

## Основная номенклатура

ZScript является объектно-ориентированным языком, и из ООП на него распространяются и парадигмы [https://www.insight-it.ru/theory/2008/tri-osnovnyx-komponenta-paradigmy-obektno-orientirovannogo-programmirovaniya/], и понятия [https://habr.com/ru/post/87119/]. Перечислим основные из них (иные будут представлены в соответствующих разделах):
* Класс: шаблон/штамп/описание/нечто неизменяемое. По классу создаются копии объектов. В классе лежит вся информация о том, _что_ будет содержатся в объектах (различные переменные) и _как_ оно будет взаимодействовать (функции, которые в ООП называются методами).
* Объект (экземпляр класса): динамическая, "живая" копия класса. Является основным "действующим лицом" в ООП — если учесть, что клонировать их даже с одного класса можно сколь угодно много (...пока памяти хватает). То есть класс — форма для заливки, описание; объект — взаимодействие, динамика.
* Наследование: использование одного класса в качестве "родителя" другого, с сохранением в дочернем классе всех свойств (переменных, методов) родительского, но и с добавлением своих. С помощью данной парадигмы выстраиваются целые иерархии и деревья классов — довольно удобно.
* Полиморфизм: возможность изменять некоторые свойства родителей в дочерних классах. Даёт б**о**льшую гибкость иерархии.
* Инкапсуляция: автоматическая защита от, например, несанкционированного доступа к святая святых — к данным того или иного объекта. Другими словами, "кто и как может работать с объектом".

Немного истории и немного теории разобраны. Перейдём к более насущной странице: где можно получить помощь по ZScript.

## "Help me!"

Итак, здесь перечислены основные ссылки, которые могут помочь в разборе, помимо данного сайта. Если не упомянуто обратного — то платформа русскоязычная:

**Discord-серверы**:
-=[Doom]=- Community [https://discord.com/invite/XbcHpc8]
Russian Doom Mapping Community [https://discord.com/invite/uDvcfz6]
Enchanced Vanilla Project [https://discord.com/invite/CuqpyK7]
Привет зелеоюа [https://discord.com/invite/xWhQcP7]
"ZDoom + EDGE + Raze [Official]" (на английском) [https://discord.com/invite/tmTSDTp]

**Сайты** (все — на английском):
Самая полная на день написания документация по языку [https://github.com/marrub--/zdoom-doc]
ZDoom wiki, раздел "ZScript" [https://zdoom.org/wiki/ZScript]
"ZScript Basics: A Guide for Non-Programmers" [https://github.com/jekyllgrim/ZScript_Basics]

**Люди**:
/bin/cat (Discord)
bolon667 (under-prog.ru, Discord, RDC)
m8f (ZDoom Community, Discord: m8f#0629, RDC)
Morthimer McMare (JSO_x) (Discord: Morthimer McMare#3123, RDC)
MutanT (SLSNe, Emot1on) (Discord: MutanT#6462; на ZDoom Community — упоминать с пингом)

## Заключение к введению

По своему опыту и я, и другие известные люди, разбирающиеся в ZScript (лично спрашивал) установили, что два лучших способа понять, как работает та или иная функция — это посмотреть на примерах в g-/l-/qzdoom.pk3 и взглянуть на исходный код G-/L-/QZDoom. Данный цикл статей не сможет и, по задумке автора, не собирается охватывать весь ZScript, так как последний слишком часто меняется (однако для большинства задач даже старой версии 2.4.0 должно хватать за глаза и по уши). Так что не стоит считать, что информация, хранящаяся внутри \*.pk3 или в исходном коде, не нужна обычному моддеру. Например, исходники незаменимы, если требуется понять значения параметров, которые используются в "нативных" функциях, или заставить их работать "неправильно", но так, как нужно Вам.

* * *

Удачи в изучении ZScript!
