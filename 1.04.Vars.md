# Работа с переменными

Практически все операции над переменными перешли в ZScript с языков C и C++.

## Числовые операции

В ZScript представлены базовые операции арифметики и элементарной алгебры: сложение, деление, деление по модулю (получение остатка), взятие абсолютного значение и так далее. Их поддерживают все встроенные целочисленные и вещественные типы данных.

### Арифметика и стандартные операторы

Положим, что `a`, `b` и `x` — любые числовые переменные.

* `a + b`: сложение;
* `a - b`: вычитание;
* `a * b`: умножение;
* `a / b`: деление;
* `a % b`: деление по модулю (взятие остатка);
* `a++`: постинкремент (прибавление единицы к значению переменной);
* `a--`: постдекремент (вычитание единицы от значения переменной);
* `++a`: преинкремент (прибавление единицы к значению переменной до остальных операций);
* `--a`: предекремент (вычитание единицы от значения переменной до остальных операций);

Операторы округления возвращают вещественное число, а не целочисленное, как можно было бы предполагать:

* `round( x )`: округление до ближайшего целого;
* `ceil( x )`: округление до ближайшего целого вверх;
* `floor( x )`: округление до ближайшего целого вниз;

* `abs( x )`: модуль числа (абсолютное значение);
* `sqrt( x )`: извлечение квадратного корня;
* `exp( x )`: экспонента ("`e^x`");
* `log( x )`: натуральный логарифм (по основанию `e`);
* `log10( x )`: логарифм по основанию 10;
* `max( a, b [, ...] )`: получение максимального числа из списка значений;
* `min( a, b [, ...] )`: получение минимального числа из списка значений;
* `clamp( x, a, b )`: фиксирование значения переменной `x` между нижней границей `a` и верхней `b` (возвращает значение не меньше `a` и не больше `b`);

### Операторы сравнения

* `a == b`: проверка на равенство двух переменных (не только чисел);
* `a != b`: проверка на неравенство двух переменных;
* `a > b`: проверка на то, что число `a` больше числа `b`;
* `a >= b`: проверка на то, что число `a` больше либо равно числу `b`;
* `a < b`: проверка на то, что число `a` меньше числа `b`;
* `a <= b`: проверка на то, что число `a` меньше либо равно числу `b`.

### Логические операторы

Часто применяются в условных операторах (операторах ветвления).

* `a && b`: логическое "И" ("AND"). Возвращает истину тогда и только тогда, когда оба значения истинны;
* `a || b`: логическое "ИЛИ" ("OR"). Возвращает истину тогда, когда хотя бы одно значение истинно;
* `!a`: логическое "НЕ" ("NOT"). Возвращает истину тогда, когда значение ложно.

### Битовые операторы

Доступны только для целочисленных типов. Соответственно, `a` и `b` — целые.

Скорость относительно логических операторов остаётся той же.

* `a & b`: битовое "И" ("OR"). Проводит операцию "И" для каждой соответственной пары битов из `a` и `b` (`1110 & 1011 == 1010`);
* `a | b`: битовое "ИЛИ" ("OR"). Проводит операцию "ИЛИ" для каждой соответственной пары битов из `a` и `b` (`1000 | 0011 == 1011`);
* `a ^ b`: битовое "ИСКЛЮЧАЮЩЕЕ ИЛИ" ("XOR"). Осуществляет проверку на неравенство для каждой соответственной пары битов из `a` и `b` (`1000 ^ 1011 == 0011`);
* `~a`: битовое "НЕ" ("NOT"). Изменяет все биты на противоположные (`~1011 == 0100`);
* `a << b`: битовое смещение влево. Смещает биты `a` на `b` битов влево с потерей старших (`00111001 << (2) == 11100100`, `11111000 << (3) == 11000000`);
* `a >> b`: битовое смещение вправо. Смещает биты `a` на `b` битов вправо с потерей младших (`11010101 >> (3) == 00011010`).



## Операторы присваивания

Присвоение любой переменной осуществляется через знак равенства:

* `a = b`: присвоить переменной `a` значение `b`;

Также существуют составные операторы присвоения:

* `a += b`: присвоить переменной `a` значение `a + b`;
* `a -= b`: присвоить переменной `a` значение `a - b`;
* `a *= b`: присвоить переменной `a` значение `a * b`;
* `a /= b`: присвоить переменной `a` значение `a / b`;
* `a %= b`: присвоить переменной `a` значение `a % b`;
* `a <<= b`: присвоить переменной `a` значение `a << b`;
* `a >>= b`: присвоить переменной `a` значение `a >> b`;
* `a &= b`: присвоить переменной `a` значение `a & b`;
* `a |= b`: присвоить переменной `a` значение `a | b`;
* `a ^= b`: присвоить переменной `a` значение `a ^ b`;



## Обращение по указателю

_Все неизвестные слова в этом подразделе можно принять как данность — чуть позже, в следующих статьях, они станут понятны._

Для того, чтобы обратиться к определённому полю/методу какого-либо сложного типа данных (экземпляра класса, структуры и так далее), необходимо после его идентификатора поставить точку и затем — название поля/метода. Эта конструкция уже встречалась и ранее:

```CPP
// Обращение к методу "printf()" встроенной структуры "console":
console.printf( "Logged." );
```



## Преобразование и конвертация элементарных типов

Зачастую ZScript сам определяет, во что нужно превратить тип данных. Но иногда ему эту информацию необходимо дать явно.

### Преобразование типа

Для того, чтобы явно указать, какой тип данных необходимо получить, нужно "обернуть" выражение в скобки с указанием типа перед ними:

```C
double b = 45.7;

int a = int( round( b ) ); // Сначала выполнится "round( b )" == "round( 45.7 )" == "46.0", затем — преобразование в целочисленное ("46").

int c = int( ceil( b / 0.63 + b ) ); // "ceil( 45.7 / 0.63 + 45.7 )" == "ceil( 72.5397 + 45.7 )" == "ceil( 118.2397 )" == "119.0". После приведения к целому получится "119".
```

Работает это не только с числами (например, см. "Приведение типа класса").

### Заметка о делении

Стоит обратить внимание на деление целого и вещественного:

```C
double double1 = 7.5;
double double2 = 2.25;
int int1 = 8;
int int1 = 2;

double1 / double2; // Результат — "double".
int1 / double1; // Результат — "double".
double1 / int1; // Результат — "int".
int1 / int2; // Результат — "int".
```

На то, какой тип получится после деления, влияет знаменатель. Для того, чтобы исправить это, достаточно обернуть его в нужный тип:

```C
double1 / int1; // Результат — "int".

double1 / double( int1 ); // Результат — "double".
int1 / double( int2 ); // Результат — "double".
```

