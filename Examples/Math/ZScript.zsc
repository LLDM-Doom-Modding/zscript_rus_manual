version "2.4.0"

class VortexDoomImp: DoomImp replaces DoomImp {
	static vector3 anglePitchToVector3( double angle, double pitch ) {
		double cosangle = cos( angle );
		double cospitch = cos( pitch );

		return ( cosangle * cospitch, sin( angle ) * cospitch, sin( pitch ) );
	} // of static vector3 anglePitchToVector3( double angle, double pitch ) {}


	// SpawnVortexActor(): creates one actor (mostly decorative) according to
	//some mathematical parameters.
	//
	// class<Actor> actorType		: Actor class to spawn.
	// double spawnRadius			: Maximal spawn radius.
	// double direction [-1; 1]		: Randomization. 1.0 = to master, 0.0 = full random, -1.0 = from master.
	// int interpolationTics		: How many tics actor must travel to the master from its spawn pos.
	// double minSpawnRadius		: Minimal spawn radius.
	// double angleLimit [-360; 360]: Relative +/- angle spawn limit. > 0 for ahead, 0 = direct spawn, < 0 for behind.
	// double pitchLimit [-90; 90]	: High/low spawn limit. > 0 is truncating, 0 = horizontal ring, < 0 is rejecting.
	Actor SpawnVortexActor( class<Actor> actorType, double spawnRadius, double direction = 1.0, int interpolationTics = 13, double minSpawnRadius = 0.0, double angleLimit = 360.0, double pitchLimit = 90.0 ) {
		// Arguments validation:
		direction = clamp( direction, -1.0, 1.0 );
		if ( interpolationTics == 0 )
			interpolationTics = 1;
		if ( spawnradius < minspawnradius )
			minspawnradius = spawnradius;
		angleLimit = clamp( angleLimit, -360.0, 360.0 );
		pitchLimit = clamp( pitchLimit, -90.0, 90.0 );

		// Generating point on a sphere-based figure:
		double angleToMaster = angle + ( FRandom( 0.0, abs( angleLimit ) ) - abs( angleLimit ) * 0.5 );
		if ( angleLimit > 0.0 )
			angleToMaster = ( angleToMaster + 180.0 ) % 360.0;

		double pitchToMaster = FRandom( -pitchLimit, pitchLimit );
		if ( pitchLimit < 0.0 )
			pitchToMaster = ( pitchToMaster + 180.0 ) % 180.0 - 90.0;

		vector3 randomizedPos = -anglePitchToVector3( angleToMaster, pitchToMaster ) * FRandom( minspawnradius, spawnradius );

		// Spawning itself:
		Actor spawned = Spawn( actortype, pos + randomizedPos );
		spawned.master = self;
		spawned.angle = angleToMaster;
		spawned.pitch = pitchToMaster;

		// Velocity randomizing:
		double pitchDirSign = ( direction < 0 )? -1.0 : 1.0;

		angleToMaster = ( angleToMaster + ( 180.0 - 180.0 * FRandom( abs( direction ), 1.0 ) ) - ( !!( direction < 0 ) * 180.0 ) ) % 360.0;
		pitchToMaster = ( pitchToMaster + pitchDirSign * 90.0 + ( 90.0 - 90.0 * FRandom( abs( direction ), 1.0 ) ) ) % 180.0 - 90.0;

		if ( interpolationTics > 0 )
			spawned.Vel3DFromAngle( Distance3D( spawned ) / double( interpolationTics + 1 ), angleToMaster, -pitchDirSign * pitchToMaster );

		return spawned;
	} // of play Actor SpawnVortexActor( class<Actor> actorType, double spawnRadius, double direction = 1.0, int interpolationTics = 13, double minSpawnRadius = 0.0, double angleLimit = 360.0, double pitchLimit = 90.0 ) {}

	States {
	Melee:
	Missile:
		TROO A 0 A_Jump( 127, "MissileAnimation2" );
	MissileAnimation1:
		TROO EF 8 {
			A_FaceTarget();

			double minSpawnRadius = FRandom( 24.0, 48.0 );
			int vortexInterpolationSpeed = Random( 5, 20 );

			for ( int i = 0; i < 8; i++ )
				SpawnVortexActor( "VortexDoomImpDecorRotating", minSpawnRadius * 2, 1.0, vortexInterpolationSpeed, minSpawnRadius, pitchLimit: 10.0 );
		}
		Goto MissileContinue;
	MissileAnimation2:
		TROO EEEE 3 {
			A_FaceTarget();

			for ( int i = 0; i < 8; i++ )
				SpawnVortexActor( "VortexDoomImpDecor", 64.0, 1.0, 13 );
		}
		TROO F 4;
	MissileContinue:
		TROO G 6 A_TroopAttack();
		Goto See;
	}

} // of class VortexDoomImp: DoomImp {}


class VortexDoomImpDecor: Actor {
	Default {
		+NOBLOCKMAP;
		+NOINTERACTION;
		+NOGRAVITY;
		+DONTSPLASH;
		RenderStyle "Translucent";
	}

	vector3 prevMasterPos;

	override void PostBeginPlay() {
		if ( master ) {
			prevMasterPos = master.pos;
			SetZ( pos.z + master.height * 0.5 );
		}

		Super.PostBeginPlay();
	}

	override void Tick() {
		// No "globalfreeze" check (everything is under control!).
		Super.Tick();

		if ( master ) {
			SetOrigin( pos + ( master.pos - prevMasterPos ), true );
			prevMasterPos = master.pos;
		}
	}

	States {
	Spawn:
		BAL1 AAAABBBB 1 A_FadeOut( 0.075 );
		Loop;
	}
} // of class VortexDoomImpDecor: Actor {}

class VortexDoomImpDecorRotating: VortexDoomImpDecor {
	override void PostBeginPlay() {
		angle -= 90.0;
		Super.PostBeginPlay();
	}

	override void Tick() {
		angle += 2.0;
		Vel3DFromAngle( vel.Length(), angle, pitch );

		Super.Tick();
	}
} // of class VortexDoomImpDecorRotating: VortexDoomImpDecor {}
