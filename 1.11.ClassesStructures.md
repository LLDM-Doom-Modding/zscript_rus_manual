# Классы и структуры

ZScript является объектно-ориентированным языком, и, соответственно, в нём есть и [понятия](https://habr.com/ru/post/87119/) оттуда:

* Класс: шаблон/штамп/описание/нечто неизменяемое. По классу создаются копии объектов. В классе лежит вся информация о том, что конкретно будет содержатся в объектах (различные переменные) и как оно будет взаимодействовать (функции, которые в ООП называются методами).
* Объект (экземпляр класса): динамическая, "живая" копия класса. Является основным "действующим лицом" в ООП — если учесть, что клонировать их в том числе и с одного класса можно сколь угодно много (...пока памяти хватает). То есть класс — форма для заливки, описание; объект — взаимодействие, динамика.
* Структура: пользовательский составной тип данных и методов работы с ними.

Структуры и классы в ZScript, несмотря на свою схожесть, различаются сильно. С натяжкой можно сказать, что структуры — это облегчённые классы с порезанными правами, всегда полностью доступные в своей области видимости, не имеющие права на создание объектов-экземпляров с себя (см. [#Классы%20и%20структуры]) и без возможности иметь внутри себя другие структуры. Оба типа — классы, структуры — могут включать переменные, методы, константы и перечислимые типы.

> _**m8f**: Ненативные (не встроенные/самописные) структуры нельзя использовать в качестве параметров, также, как и возвращать их из функций. Но зато они легче классов_.

Напомню, что обращение к какому-либо полю или методу класса производится посредством точки (см. 1.04, "Обращение по указателю").


## Объвление структур и классов

Для того, чтобы объявить структуру, необходимо её

Порядок блоков может варьироваться в зависимости от нужды, так как он не имеет значения.

```Csharp
struct <имя_структуры> {
    [<константа> = <значение>;
    [...]]

    [<перечислимый_тип>;
    [...]]

    <тип_переменной> <имя_поля_структуры>;
    [...]

    [<метод_структуры>;
    [...]]
}
[...]
```

Так как класс является описанием именно действующих лиц (объектов) — он должен быть более гибким, чем структура. В нём возможно наследование (см. 1.11), добавление вложенных структур и, в случае создания объектов мира — акторов — ещё и код взаимодействия с игровой вселенной.

```Csharp
class <имя_класса> [: <от_кого_наследуется>] {
    [<константа> = <значение>;
    [...]]

    [<перечислимый_тип>;
    [...]]

    [<структура>;
    [...]]

    [<default-блок>;] // Только в случае наследования от класса Actor или его потомков.

    [<тип_переменной> <имя_переменной>;
    [...]]

    [<метод_класса>
    [...]]

    [<states-блок>] // Только в случае наследования от класса Actor или его потомков.
}
[...]
```



### Пример синтаксиса (скорее всего, будет куда-либо перенесён)

```Csharp
version "2.4.0"

#include "constants.zsc"        // Положим, здесь лежат второстепенные константы.
#include "zscript/weapons.zsc"
#include "zscript/monsters.zsc"
#include "zscript/npcs.zsc"

enum NPCTeams {
    NPCT_Neutral = 0,
    NPCT_Normal = NPCT_Neutral // ...Почему бы и нет?
    NPCT_Red,                  // == "NPCT_Neutral + 1", то есть "1".
    NPCT_Yellow,               // "2".
    NPCT_Green,
    NPCT_Blue, 
    NPCT_Gray,                 // "5".

    NPCT_LastTeam = NPCT_Gray
    // Чтобы каждый раз не вспоминать, какая там команда у нас последняя -- делаем себе упрощение (здесь будет "NPCT_Gray", то есть "5").
}

class BaseNPC: Actor {
    uint team;
    double bravefactor;

    Default {
        Monster;
        +FRIENDLY;
        Health 100;
    }

    override void BeginPlay() {
        team = Random( NPCT_Neutral, NPCT_LastTeam ); // Пользуемся мнемоническим упрощением...
        bravefactor = FRandom( 0.1, 1.0 );
        Super.BeginPlay();
    } // of override void BeginPlay() {
}
```



## Указатели на экземпляры классов

Указатели служат, как можно понять по названию, для указания процессору, с каким конкретно объектом ему нужно работать. Фактически, количество типов указателей неограничено, так как любой новый написанный класс уже порождает тип указателя. 

### Указатель на себя

У каждого экземпляра класса есть автоматически создаваемый указатель `self` — фактически, указатель на самого себя, на текущий объект. 

Зачастую используется как аргумент в методе:

```CPP
// Уменьшить здоровье своей цели, передав в качестве атакующего себя самого.
// Забавно и парадоксально, но подобный вызов используется нередко. Не отовсюду можно "попасть" в цель по-другому.

target.DamageMobj( self, self, 25, 'None' );

// Из "gzdoom.pk3::actor.txt": "native virtual int DamageMobj( Actor inflictor, Actor source, int damage, Name mod, int flags = 0, double angle = 0 );"
```

Также можно использовать, если происходит коллизия названия какого-то поля объекта и локальной переменной (у последних приоритет). Но не советую доводить до этого, лучше входные параметры называйте иначе: запутаться будет сложнее.

```CPP
class SomeClass {
    int a;
    double b;

    void Init( int a, String b = "" ) {
        self.a = a;
        self.b = 0.0;

        console.printf( b ); // Вот и думай, тут у нас как "double b" воспримется или как "String b".
                             //(Ответ — второе, как строка. Но сходу это совсем не очевидно).
    }
}
```

_Существуют специализированная обработка указателя `self` в классах, наследованных от `StateProvider`; см. статью 2.04 — "Actors"._

### Основополагающие типы классов

С каждым можно ознакомиться подробнее в соответствущей статье.

```
Actor
// Указатель на объект типа "Actor". Как раз акторами и являются все
//объекты в игровом мире -- игроки, монстры, оружие, декорации, 
//файерболы, дымок от пуль, источники динамического света и так далее.
// Класс "Actor" наследуется от класса "Thinker".

Thinker
// Thinker -- любой объект, имеющий право хоть как-то взаимодействовать
//с миром. Это, собственно, все акторы, эффекты секторов, "сущности" 
//ботов, декали, маркеры автокарты и иные объекты, прямо или косвенно
//связанные с игровым миром.
// Наследуется от "Object".

Object
// Разработчики ZScript решили всех запутать и сделали класс c названием
//"Object". Фактически это просто удобная оболочка для мира для 
//стандартного "пустого" класса.

ThinkerIterator
ActorIterator
// Вспомогательные объекты, позволяют перебрать всех Thinker'ов в мире,
//удовлетворяющих фильтру наследования.

BlockThingsIterator
BlockLinesIterator
// Вспомогательные объекты, используются для перебора всех блокирующих
//линий или акторов вокруг определённого актора или определённой позиции
//в мире.
```

Дерево наследований объектов мира. Через "<...>" обозначены остальные, не основные классы. На наследование самописных это никак не влияет.

```
Object

  Thinker
  > Actor              // Decorate умеет работать только с акторами...
  |   Inventory        // Базовый класс инвентаря.
  |     StateProvider
  |       CustomInventory
  |       Weapon       // Базовый класс оружия.
  |         <...>
  |     Powerup        // Базовый класс Powerup'ов.
  |       <...>
  |     PowerupGiver
  |     <...>
  |   <...>
  > SectorEffect
  |   Lighting
  |   Mover
  |     MovingFloor
  |       Floor
  |     MovingCeiling
  |       Ceiling
  | <...>

  ThinkerIterator
  ActorIterator
  BlockThingsIterator
  BlockLinesIterator

  <...>
```

