Для синтаксиса кода см. "ZScript. Синтаксис кода" [].

ZScript — вещь довольно мощная; он является самым гибким и быстрым средь всех языков, посвящённых Doom. У него есть своя логика, как внешняя, так и внутренняя; и о первой из них — о синтаксисе — и будет статья.

По визуальному представлению он не сильно отличается от ООП-языков типа C++, C# или Java. Все основные синтаксические формы в ZScript взяты с современного стандарта C++/C#; дополнительные будут разобраны в отдельной статье. Единственное, что хотелось бы добавить — в этом языке нет различия меж строчными и заглавными буквами, регистр букв в коде игнорируется.

## Комментарии

Начнём не с основной функции, так как она будет помогать нам везде в последующих разборах.

Самая полезная в любом языке программирования вещь — это комментарии. Они позволяют прояснить непонятные моменты, временно убрать часть пока что ненужного кода, да и просто не забыть, что происходит на данном конкретном участке, если возвращаешься к программе эдак года через два! И ZScript — не исключение. Он предоставляет два варианта обозначения того, что текст — комментарий. Оба эти варианта пришли с незапамятных времён — многострочный со стандарта C89 [http://port70.net/~nsz/c/c89/c89-draft.html], однострочный — с C99 [http://port70.net/~nsz/c/c99/n1256.pdf] (хотя, конечно, использовался и ранее, примерно с 90-го года).

```C
// Так будут обозначаться однострочные комментарии (игнорируются препроцессором до конца строки);

/*  Так -- многострочные комментарии (также 
   игнорируются, но по всей длине, до закрывающей 
   последовательности символов); */```

К слову: хорошим тоном считается, когда программа (или, в нашем случае, скрипт) самозадокументирована. Иначе говоря, когда любую логически выделенную часть кода можно понять отдельно от других. А тут без комментариев не обойтись...

## Синтаксис команд препроцессора

Препроцессор — программа, которая прямо перед компиляцией проекта переводит код в пригодный для обработки. В случае ZScript — подключает дополнительные файлы, проверяет синтаксические ошибки и убирает из кода комментарии.

У него есть буквально две команды: выбор эмулируемой версии и добавление компилятору путей к подключаемым файлам. 

```C
version "<версия>" 
/* Эмулируемая версия ZScript. Нужно указывать лишь один раз, в начале основного файла. 
   Примечание: я везде, где возможно, в примерах буду использовать самую оптимальную 
 по совместимости/функционалу -- 2.4.0 (последняя на момент написания -- 4.4.2). 
*/ // Пример:

version "3.3"```

```C
#include "<путь_до_файла>" 
[...]
/* Подключаемый модуль, можно использовать неоднократно и не только в заглавном файле. 
   В кавычках пишется относительный путь до дополнительного, подключаемого файла. Стоит 
 использовать, чтобы не создавать лишь один файл на десятки тысячи строк и сотни классов. 
 Если Вы изучали любой язык программирования, или даже ACS/Decorate -- то принцип 
 действия команды здесь тот же.
*/ // Пример:

#include "zscript/sbarinfo.zsc"
#include "zscript/eventhandlers.zsc"
#include "zscript/monsters.zsc"
#include "zscript/weapons.zsc"```

## Объявление констант и типов

### Константы и перечисляемые типы

Константы — это неизменяемые значения в программе. Используются для использования одного и того же значения по программе. Например, математических констант. Или, если какие-нибудь акторы у Вас нарисованы в Hi-Res одного порядка, то для указания одинакового значения Scale’а (затем, если разрешение поменяется, можно просто-напросто сменить значение константы, и везде по программе, где нужно, она изменится).

```C
const <константа> = <значение>;
[...]
/* Незименяемое значение. На простых значениях аналог #define в C/C++, а не 
 const, как можно было бы подумать. На средних (например, массивов строк) -- 
 да, скорее const. На сложных и составных типах не работает, ZScript местами 
 ограничен в самых неожиданных местах.
*/ // Пример:

const playerMinSize = 3;
const playerMaxSize = 20;
const winString = "You win! Congratulations!";
const looseString = "You loose...";
const monsterXMultiplier = 4.444;```

Далее идёт так называемый "перечисляемый тип" (изредка можно услышать "енумерат"). Грубо говоря, это константы в удобной для перечислений форме записи. Почему удобный? Потому что есть автоматический инкремент для следующего значения, если не указано что-либо другое. Почему константы? Ну... Неизменяемые.

```C
enum <имя> { 
     <имя [= <значение>]>,
    [<имя [= <значение>]>,]
    [...]
};
[...]
/* Перечисляемый тип. Если значения не указаны то берётся "0" для первого 
 и "+ 1 от предыдущего значения" для последующих. Таким образом, достигается 
 полная автоматизированность -- можно просто перечислить все нужные имена 
 подряд и затем даже не задумываться, какие у них значения.
   Одинаковые числа для разных имён в ZScript-енумератах вполне законны.
*/ // Пример:

enum EGAColors {
    EGA_Black = 0,  // Пусть он и авто-инициализируется, но мне 
                    // спокойнее, когда я знаю его точно...
    EGA_DarkBlue,   // "EGA_Black + 1" == 1;
    EGA_DarkGreen,  // "EGA_DarkBlue + 1" == 2;
    EGA_Cyan,       // "EGA_DarkGreen + 1" == 3;
    EGA_DarkRed,    // 4;
    EGA_Purple,     // 5...
    EGA_Brown,
    EGA_LightGray,
    EGA_DarkGray,
    EGA_Blue,
    EGA_LightGreen,
    EGA_LightBlue,
    EGA_LightRed,
    EGA_Pink,       // ...
    EGA_Yellow,     // 14;
    EGA_White       // 15. На последней строке запятая возможна, но просто не нужна.
}; // <-- Про точку с запятой в конце многие часто забывают (я не исключение).

enum testEnum {
    TE_One = 1,             // 1;
    TE_Two,                 // 2;
    TE_Couple = TE_Two,     // Также 2;
    TE_Three,               // 3;
    TE_Four,                // 4;
    TE_Five,                // 5;
    TE_Ten = 10,            // 10;
    TE_Eleven,              // 11;
    TE_Twelve = TE_Ten + 2, // 12;
    TE_Dozen = TE_Twelve    // Тоже 12.
};```

### Объвление структур и классов

Структуры и классы в ZScript разделены мало. Можно сказать, что структуры — это классы с порезанными правами, всегда полностью доступные в своей области видимости, не имеющие права на создание объектов-экземпляров с себя (см. "Номенклатура" [ZScript. Введение. Основные понятия]) и без возможности иметь другие структуры. Оба типа — классы, структуры — могут включать в себя и константы, и перечислимые типы (тогда они будут «видны» лишь внутри этой структуры/класса), но помимо них — ещё и переменные, и методы.

Порядок блоков может варьироваться в зависимости от нужды, так как он не имеет значения.

```C
struct <имя_структуры> {
    [<константа> 
    [...]]

    [<перечислимый_тип> 
    [...]]

    <тип_переменной> <имя_поля_структуры>;
    [...]

    [<метод_структуры>
    [...]]
}; // <-- Обязательна! Вечно её забудут...
[...]```

Так как класс является описанием именно действующих лиц (объектов) — он должен быть более гибким, чем структура. В нём возможно наследование (см. «Номенклатура»), добавление вложенных структур и, в случае создания объектов мира (более известных даже в Decorate как "акторы"/"актёры" — "Actors"), ещё и код взаимодействия с игровой вселенной.

```Csharp
class <имя_класса> [: <от_кого_наследуется>] {
    [<константа> = <значение>;
    [...]]

    [<перечислимый_тип>;
    [...]]

    [<структура>;
    [...]]

    [<default-блок>;] // В случае наследования от класса Actor или его потомков.

    [<тип_переменной> <имя_переменной>;
    [...]]

    [<метод_класса>
    [...]]

    [<states-блок>] // В случае наследования от класса Actor или его потомков.
}
[...]```

## Пример синтаксиса (будет куда-то перенесён)

```Csharp
version "2.4.0"

#include "constants.zsc"        // Положим, здесь лежат второстепенные константы.
#include "zscript/weapons.zsc"
#include "zscript/monsters.zsc"
#include "zscript/npcs.zsc"

enum NPSTeams {
    NPST_Neutral = 0,
    NPST_Normal = NPST_Neutral // ...Почему бы и нет?
    NPST_Red,                  // == "NPST_Neutral + 1", то есть "1".
    NPST_Yellow,               // "2".
    NPST_Green,
    NPST_Blue, 
    NPST_Gray,                 // "5".

    NPST_Quantity = NPST_Gray
    // Чтобы каждый раз не вспоминать, какая там команда у нас последняя -- делаем себе упрощение (здесь будет "NPST_Gray", то есть "5").
};

class BaseNPS: Actor {
    uint team;
    double bravefactor;

    Default {
        Monster;
        +FRIENDLY;
        Health 100;
    }

    override void BeginPlay() {
        team = Random( NPST_Neutral, NPST_Quantity ); // Пользуемся упрощением...
        bravefactor = FRandom( 0.1, 1.0 );
        Super.BeginPlay();
    } // of override void BeginPlay() {
}```
